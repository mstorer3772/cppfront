{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview: What are Cpp2 and cppfront? How do I get and build cppfront?","text":""},{"location":"#what-is-cpp2","title":"What is Cpp2?","text":"<p>\"Cpp2,\" short for \"C++ syntax 2,\" is my (Herb Sutter's) personal project to try to make writing ordinary C++ types/functions/objects be much simpler and safer, without breaking backward compatibility. Bjarne Stroustrup said it best:</p> <p>\"Inside C++, there is a much smaller and cleaner language struggling to get out.\" \u2003\u2003\u2014 Bjarne Stroustrup, The Design and Evolution of C++ (D&amp;E), 1994</p> <p>\"Say 10% of the size of C++ in definition and similar in front-end compiler size. ... most of the simplification would come from generalization.\" \u2003\u2003\u2014 Bjarne Stroustrup, ACM History of Programming Languages III, 2007</p> <p>My goal is to try to prove that Stroustrup is right: that it's possible and desirable to have true C++ with all its expressive power and control and with full backward compatibility, but in a flavor that's 10x simpler with fewer quirks and special cases to remember, <sup>1</sup> and 50x safer where it's far easier to not write security bugs by accident.</p> <p>We can't make an improvement that large to C++ via gradual evolution to today's syntax, because some important changes would require changing the meaning of code written in today's syntax. For example, we can never change a language feature default in today's syntax, not even if the default creates a security vulnerability pitfall, because changing a default would break vast swathes of existing code. Having a distinct alternative syntax gives us a \"bubble of new code\" that doesn't exist today, and have:</p> <ul> <li> <p>Freedom to make any desired improvement, without breaking any of today's code. Cpp2 is designed to take all the consensus C++ best-practices guidance we already teach, and make it the default when using \"syntax 2.\" Examples: Writing unsafe type casts is just not possible in Cpp2 syntax; and Cpp2 can change language defaults to make them simpler and safer. You can always \"break the glass\" when needed to violate the guidance, but has to opt out explicitly to write unsafe code, so if the program has a bug you can grep for those places to look at first. For details, see Design note: Unsafe code.</p> </li> <li> <p>Perfect link compatibility always on, perfect source compatibility always available (but you pay for it only if you use it). Any type/function/object/namespace written in either syntax is always still just a normal C++ type/function/object/namespace, so any code or library written in either Cpp2 or today's C++ syntax (\"Cpp1\" for short) can seamlessly call each other, with no wrapping/marshaling/thunking. You can write a \"mixed\" source files that has both Cpp2 and Cpp1 code and get perfect backward C++ source compatibility (even SFINAE and macros), or you can write a \"pure\" all-Cpp2 source file and write code in a 10x simpler syntax.</p> </li> </ul> <p>What it isn't. Cpp2 is not a successor or alternate language with its own divergent or incompatible ecosystem. For example, it does not have its own nonstandard incompatible modules/concepts/etc. that compete with the Standard C++ features; and it does not replace your Standard C++ compiler and other tools.</p> <p>What it is. Cpp2 aims to be another \"skin\" for C++ itself, just a simpler and safer way to write ordinary C++ types/functions/objects. It seamlessly uses Standard C++ modules and concepts requirements and other features, and it works with all existing C++20 or higher compilers and tools right out of the box with zero overhead.</p>"},{"location":"#what-is-cppfront","title":"What is cppfront?","text":"<p>Cppfront is a compiler that compiles Cpp2 syntax to today's Cpp1 syntax. This lets you start trying out Cpp2 syntax in any existing C++ project and build system just by renaming a source file from <code>.cpp</code> to <code>.cpp2</code> and adding a build step, and the result Just Works with every C++20 or higher compiler and all existing C++ tools (debuggers, build systems, sanitizers, etc.).</p> <p>This deliberately follows Bjarne Stroustrup's wise approach with cfront, the original C++ compiler: In the 1980s and 1990s, Stroustrup created cfront to translate C++ to pure C, and similarly ensured that C++ could be interleaved with C in the same source file, and that C++ could always call any C code with no wrapping/marshaling/thunking. By providing a C++ compiler that emitted pure C, Stroustrup ensured full compatibility with the C ecosystems that already existed, and made it easy for people to start trying out C++ code in any existing C project by adding just another build step to translate the C++ to C first, and the result Just Worked with existing C tools.</p>"},{"location":"#how-do-i-get-and-build-cppfront","title":"How do I get and build cppfront?","text":"<p>The full source code for cppfront is at the Cppfront GitHub repo.</p> <p>Cppfront builds with any recent C++ compiler. Go to the <code>/cppfront/source</code> directory, and run one of the following:</p> <p> MSVC build instructions (Visual Studio 2019 version 16.11 or higher)<pre><code>cl cppfront.cpp -std:c++20 -EHsc\n</code></pre> GCC build instructions (GCC 10 or higher)<pre><code>g++ cppfront.cpp -std=c++20 -o cppfront\n</code></pre> Clang build instructions (Clang 12 or higher)<pre><code>clang++ cppfront.cpp -std=c++20 -o cppfront\n</code></pre> <p>That's it!</p>"},{"location":"#next-hello-world","title":"\u27a4 Next: Hello, world!","text":"<ol> <li> <p>I'd ideally love to obsolete ~90% of my own books. I know that Cpp2 can eliminate that much of the C++ guidance I've personally had to write and teach over the past quarter century, by removing inconsistencies and pitfalls and gotchas, so that they're either impossible to write or are compile-time errors (either way, we don't have to teach them). I love writing C++ code... I just want it to be easier and safer by default.\u00a0\u21a9</p> </li> </ol>"},{"location":"cpp2/aliases/","title":"Aliases","text":""},{"location":"cpp2/aliases/#namespace-aliases","title":"Namespace aliases","text":"<p>TODO</p>"},{"location":"cpp2/aliases/#type-aliases","title":"Type aliases","text":"<p>TODO</p>"},{"location":"cpp2/aliases/#function-aliases","title":"Function aliases","text":"<p>TODO</p>"},{"location":"cpp2/aliases/#object-aliases","title":"Object aliases","text":"<p>TODO</p>"},{"location":"cpp2/common/","title":"Common programming concepts","text":""},{"location":"cpp2/common/#comments","title":"Comments","text":"<p>The usual <code>// line comments</code> and <code>/* stream comments */</code> are supported. For example:</p> Example: Comments<pre><code>//  A line comment: After //, the entire\n//  rest of the line is part of the comment\n\n/*\n    A stream comment: After /*, everything until the\n    next * / (without a space between) is part of the\n    comment. Note that stream comments do not nest.\n */\n</code></pre>"},{"location":"cpp2/common/#reserved-keywords","title":"Reserved keywords","text":"<p>Cpp2 has very few globally reserved keywords; nearly all keywords are contextual, where they have their special meaning when they appear in a particular place in the grammar. For example:</p> <ul> <li> <p><code>new</code> is used as an ordinary function to do allocation (e.g., <code>shared.new&lt;widget&gt;(1, 2, 3)</code>).</p> </li> <li> <p><code>struct</code> and <code>enum</code> are used as function names in the metafunctions library.</p> </li> <li> <p><code>type</code> can be used as an ordinary name (e.g., <code>std::common_type&lt;T1,T2&gt;::type</code>).</p> </li> </ul> <p>In rare cases, usually when consuming code written in other languages, you may need to write a name that is a reserved keyword. The way to do that is to prefix it with <code>__identifer__</code>, which treats it as an ordinary identifier (without the prefix).</p>"},{"location":"cpp2/common/#fundamental-data-types","title":"Fundamental data types","text":"<p>Cpp2 supports the same fundamental types as today's Cpp1, but additionally provides the following aliases in namespace <code>cpp2</code>:</p> Fixed-width types Synonym for <code>i8</code> <code>std::int8_t</code> <code>i16</code> <code>std::int16_t</code> <code>i32</code> <code>std::int32_t</code> <code>i64</code> <code>std::int64_t</code> <code>u8</code> <code>std::uint8_t</code> <code>u16</code> <code>std::uint16_t</code> <code>u32</code> <code>std::uint32_t</code> <code>u64</code> <code>std::uint64_t</code> Variable-width types  (Cpp2-compatible single-word names) Synonym for (these multi-word names are not allowed in Cpp2) <code>ushort</code> <code>unsigned short</code> <code>uint</code> <code>unsigned int</code> <code>ulong</code> <code>unsigned long</code> <code>longlong</code> <code>long long</code> <code>ulonglong</code> <code>unsigned long long</code> <code>longdouble</code> <code>long double</code> For compatibility/interop only, so deliberately ugly names Synonym for Notes <code>_schar</code> <code>signed char</code> Normally, prefer <code>i8</code> instead <code>_uchar</code> <code>unsigned char</code> Normally, prefer <code>u8</code> instead"},{"location":"cpp2/common/#type-qualifiers","title":"Type qualifiers","text":"<p>Types can be qualified with <code>const</code> and <code>*</code>. Types are written left-to-right, so a qualifier always applies to what immediately follows it. For example, to declare a <code>const</code> pointer to a non-<code>const</code> pointer to a <code>const i32</code> object, write:</p> Example: Type qualifiers<pre><code>//  A const pointer to a non-const pointer to a const i32 object\np: const * * const i32;\n</code></pre>"},{"location":"cpp2/common/#literals","title":"Literals","text":"<p>Cpp2 supports the same <code>'c'</code>haracter, <code>\"string\"</code>, binary, integer, and floating point literals as Cpp1, including most Unicode encoding prefixes and raw string literals.</p> <p>Cpp2 supports using Cpp1 user-defined literals for compatibility, to support seamlessly using existing libraries. However, because Cpp2 has unified function call syntax (UFCS), the preferred way to author the equivalent in Cpp2 is to just write a function or type name as a <code>.</code> call suffix. For example:</p> <ul> <li> <p>You can create a <code>u8</code> value by writing either <code>u8(123)</code> or <code>123.u8()</code>. <sup>1</sup></p> </li> <li> <p>You can write a 'constexpr' function like <code>nm: (value: i64) -&gt; my_nanometer_type == { /*...*/ }</code> that takes an integer and returns a value of a strongly typed \"nanometer\" type, and then create a <code>nm</code> value by writing either <code>nm(123)</code> or <code>123.nm()</code>.</p> </li> </ul> <p>Both <code>123.n()</code> and <code>123.u8()</code> are very similar to user-defined literal syntax, and more general.</p>"},{"location":"cpp2/common/#operators","title":"Operators","text":"<p>Operators have the same precedence and associativity as in Cpp1, but some unary operators that are prefix (always or sometimes) in Cpp1 are postfix (always) in Cpp2.</p>"},{"location":"cpp2/common/#unary-operators","title":"Unary operators","text":"<p>The operators <code>!</code>, <code>+</code>, and <code>-</code> are prefix, as in Cpp1. For example:</p> Example: Prefix operators<pre><code>if !vec.empty() {\n    vec.emplace_back( -123.45 );\n}\n</code></pre> Unary operator Cpp2 example Cpp1 equivalent <code>!</code> <code>!vec.empty()</code> <code>!vec.empty()</code> <code>+</code> <code>+100</code> <code>+100</code> <code>-</code> <code>-100</code> <code>-100</code> <p>The operators <code>.</code>, <code>*</code>, <code>&amp;</code>, <code>~</code>, <code>++</code>, <code>--</code>, <code>()</code>, <code>[]</code>, and <code>$</code> are postfix. For example:</p> Example: Postfix operators<pre><code>//  Cpp1 examples, from cppfront's own source code:\n//      address = &amp;(*tokens)[pos + num];\n//      is_void = *(*u)-&gt;identifier == \"void\";\n//  Cpp2 equivalents:\n        address = tokens*[pos + num]&amp;;\n        is_void = u**.identifier* == \"void\";\n</code></pre> <p>Postfix notation lets the code read fluidly left-to-right, in the same order in which the operators will be applied, and lets declaration syntax be consistent with usage syntax. For more details, see Design note: Postfix operators.</p> <p>Note: The function call syntax <code>f(x)</code> calls a namespace-scope function, or a function object, named <code>f</code>. The function call syntax <code>x.f()</code> is a unified function call syntax (aka UFCS) that calls a type-scope function in the type of <code>x</code> if available, otherwise calls the same as <code>f(x)</code>. For details, see Design note: UFCS.</p> Unary operator Cpp2 example Cpp1 equivalent <code>.</code> <code>obj.f()</code> <code>obj.f()</code> <code>*</code> <code>pobj*.f()</code> <code>(*pobj).f()</code> or <code>pobj-&gt;f()</code> <code>&amp;</code> <code>obj&amp;</code> <code>&amp;obj</code> <code>~</code> <code>val~</code> <code>~val</code> <code>++</code> <code>iter++</code> <code>++iter</code> <code>--</code> <code>iter--</code> <code>--iter</code> <code>(</code> <code>)</code> <code>f( 1, 2, 3)</code> <code>f( 1, 2, 3)</code> <code>[</code> <code>]</code> <code>vec[123]</code> <code>vec[123]</code> <code>$</code> <code>val$</code> (reflection \u2014 no C++23 equivalent) <p>Because <code>++</code> and <code>--</code> always have in-place update semantics, we never need to remember \"use prefix <code>++</code>/<code>--</code> unless you need a copy of the old value.\" If you do need a copy of the old value, just take the copy before calling <code>++</code>/<code>--</code>.</p> <p>Unary suffix operators must not be preceded by whitespace. When <code>*</code>, <code>&amp;</code>, and <code>~</code> are used as binary operators they must be preceded by whitespace. For example:</p> Unary postfix operators thatare also binary operators Cpp2 example Cpp1 equivalent <code>*</code> <code>pobj* * 42</code> <code>(*pobj)*42</code> <code>&amp;</code> <code>obj&amp; &amp; mask</code> <p> (note: allowed in unsafe code only) <code>&amp;obj &amp; mask</code> <code>~</code> <code>~val ~ bitcomplement</code> <code>val~ ~ bitcomplement</code> <p>For more details, see Design note: Postfix unary operators vs binary operators.</p>"},{"location":"cpp2/common/#binary-operators","title":"Binary operators","text":"<p>Binary operators are the same as in Cpp1. From highest to lowest precedence:</p> Binary operators grouped by precedence <code>*</code>, <code>/</code>, <code>%</code> <code>+</code>, <code>-</code> <code>&lt;&lt;</code>, <code>&gt;&gt;</code> <code>&lt;=&gt;</code> <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> <code>==</code>, <code>!=</code> <code>&amp;</code> <code>^</code> <code>|</code> <code>&amp;&amp;</code> <code>||</code> <code>=</code> and compound assignment <ol> <li> <p>Or <code>123.cpp2::u8()</code> if you aren't <code>using</code> the namespace or that specific name.\u00a0\u21a9</p> </li> </ol>"},{"location":"cpp2/declarations/","title":"Declaration syntax","text":""},{"location":"cpp2/declarations/#unified-declaration-syntax","title":"Unified declaration syntax","text":"<p>All Cpp2 declarations are written as \"name <code>:</code> kind <code>=</code> statement\".</p> <ul> <li> <p>The <code>:</code> is pronounced \"is a.\"</p> </li> <li> <p>The <code>=</code> is pronounced \"defined as.\"</p> </li> <li> <p>The statement is typically an expression statement (e.g., <code>a + b();</code>) or a compound statement (e.g., <code>{ /*...*/ return c(d) / e; }</code>).</p> </li> <li> <p>Various parts of the syntax allow a <code>_</code> \"don't care\" wildcard or can be omitted entirely to accept a default (e.g., <code>x: int = 0;</code> can be equivalently written <code>x: _ = 0;</code> or <code>x := 0;</code> both of which deduce the type).</p> </li> </ul>"},{"location":"cpp2/declarations/#examples","title":"Examples","text":"Example: Consistent declarations \u2014 name : kind = statement<pre><code>//  n is a namespace defined as the following scope\nn: namespace\n= {\n    //  shape is a type defined as the following scope\n    shape: type\n    = {\n        //  points is an object of type std::vector&lt;point2d&gt;,\n        //  defined as having an empty default value\n        //  (type-scope objects are private by default)\n        points: std::vector&lt;point2d&gt; = ();\n\n        //  draw is a function taking 'this' and 'canvas' parameters\n        //  and returning bool, defined as the following body\n        //  (type-scope functions are public by default)\n        //      - this is as if 'this: shape', an object of type shape\n        //      - where is an object of type canvas\n        draw: (this, where: canvas) -&gt; bool\n        = {\n            //  pen is an object of deduced (omitted) type 'color',\n            //  defined as having initial value 'color::red'\n            pen := color::red;\n\n            //  success is an object of deduced (omitted) type bool,\n            //  defined as having initial value 'false'\n            success := false;\n\n            // ...\n\n            return success;\n        }\n\n        //  count is a function taking 'this' and returning a type\n        //  deduced from its body, defined as a single-expression body\n        count: (this) = points.ssize();\n\n        //  ...\n    }\n\n    //  color is an @enum type (see Note)\n    color: @enum type = { red; green; blue; }\n}\n</code></pre> <p>Note: <code>@enum</code> is a metafunction, which provides an easy way to opt into a group of defaults, constraints, and generated functions. For details, see <code>@enum</code>, <code>@flag_enum</code></p>"},{"location":"cpp2/declarations/#requires-constraints","title":"<code>requires</code> constraints","text":"<p>TODO</p>"},{"location":"cpp2/expressions/","title":"Common expressions","text":""},{"location":"cpp2/expressions/#_-the-dont-care-wildcard-including-explicit-discard","title":"<code>_</code> \u2014 the \"don't care\" wildcard, including explicit discard","text":"<p><code>_</code> is pronounced \"don't care\" and allowed as a wildcard in most contexts. For example:</p> Example: _ wildcard<pre><code>//  We don't care about the guard variable's name\n_ : std::lock_guard = mut;\n\n//  If we don't care to write the variable's type, deduce it\nx : _ = 42;\n    // in cases like this, _ can be omitted...\n    // this is equivalent to \"x := 42;\"\n\nreturn inspect v -&gt; std::string {\n    is std::vector = \"v is a std::vector\";\n    is _ = \"unknown\";   // don't care what else, match anything\n};\n</code></pre> <p>Cpp2 treats all function outputs (return values, and results produced via <code>inout</code> and <code>out</code> parameters) as important, and does not let them be silently discarded by default. To explicitly discard such a value, assign it to <code>_</code>. For example:</p> Example: Using _ for explicit discard<pre><code>_ = vec.emplace_back(1,2,3);\n    // \"_ =\" is required to explicitly discard emplace_back's\n    // return value (which is non-void since C++17)\n\n{\n    x := my_vector.begin();\n    std::advance(x, 2);\n    _ = x;  // required to explicitly discard x's new value,\n            // because std::advance modifies x's value\n}\n</code></pre> <p>For details, see Design note: Explicit discard. In Cpp2, data is always initialized, data is never silently lost, data flow is always visible. Data is precious, and it's always safe. This feels right and proper to me.</p>"},{"location":"cpp2/expressions/#is-safe-typevalue-queries","title":"<code>is</code> \u2014 safe type/value queries","text":"<p>An <code>x is C</code> expression allows safe type and value queries, and evaluates to <code>true</code> if <code>x</code> matches constraint <code>C</code>. It supports both static and dynamic queries, including customization with support for the standard dynamically typed libraries <code>std::variant</code>, <code>std::optional</code>, and <code>std::any</code> provided in the box.</p> <p>There are two kinds of <code>is</code>:</p> <ul> <li>A type query, where <code>C</code> is a type constraint: A type, a template name, a concept, or a type predicate. Here <code>x</code> may be a type, or an object or expression; if it is an object or expression, the query refers to <code>x</code>'s type.</li> </ul> Type constraint kind Example Static type query <code>x is int</code> Dynamic type query <code>ptr* is Shape</code> Static template type query <code>x is std::vector</code> Static concept query <code>x is std::integral</code> <ul> <li>A value query, where <code>C</code> is a value constraint: A value, or a value predicate. Here <code>x</code> must be an object or expression.</li> </ul> Value constraint kind Example Value <code>x is 0</code> Value predicate <code>x is (in(10, 20))</code> <p><code>is</code> is useful throughout the language, including in <code>inspect</code> pattern matching alternatives. <code>is</code> is extensible, and works out of the box with <code>std::variant</code>, <code>std::optional</code>, and <code>std::any</code>. For examples, see:</p> <ul> <li><code>mixed-inspect-templates.cpp2</code></li> <li><code>mixed-inspect-values.cpp2</code></li> <li><code>mixed-inspect-values-2.cpp2</code></li> <li><code>mixed-type-safety-1.cpp2</code></li> <li><code>pure2-enum.cpp2</code></li> <li><code>pure2-inspect-expression-in-generic-function-multiple-types.cpp2</code></li> <li><code>pure2-inspect-fallback-with-variant-any-optional.cpp2</code></li> <li><code>pure2-type-safety-1.cpp2</code></li> <li><code>pure2-type-safety-2-with-inspect-expression.cpp2</code></li> </ul>"},{"location":"cpp2/expressions/#as-safe-casts-and-conversions","title":"<code>as</code> \u2014 safe casts and conversions","text":"<p>An <code>x as T</code> expression allows safe type casts. <code>x</code> must be an object or expression, and <code>T</code> must be a type. It supports both static and dynamic typing, including customization with support for the standard dynamically typed libraries <code>std::variant</code>, <code>std::optional</code>, and <code>std::any</code> provided in the box. For example:</p> Example: Using as<pre><code>main: () = {\n    a: std::any = 0;                // a's type is now int, value 0\n    test(a);                        // prints \"zero\"\n    a = \"plugh\" as std::string;     // a's type is now std::string, value \"plugh\"\n    test(a);                        // prints \"plugh\"\n    test(\"xyzzy\" as std::string);   // prints \"xyzzy\"\n}\n\n//  A generic function that takes an argument 'x' of any type,\n//  same as \"void test( auto const&amp; x )\" in C++20 syntax\ntest: (x) = {\n    std::cout &lt;&lt; inspect x -&gt; std::string {\n        is 0           = \"zero\";\n        is std::string = x as std::string;\n        is _           = \"(no match)\";\n    } &lt;&lt; \"\\n\";\n}\n</code></pre>"},{"location":"cpp2/expressions/#inspect-pattern-matching","title":"<code>inspect</code> \u2014 pattern matching","text":"<p>An <code>inspect expr -&gt; Type</code> expression allows pattern matching using <code>is</code>.</p> <ul> <li><code>expr</code> is evaluated once.</li> <li>Each alternative spelled <code>is C</code> is evaluated in order as if called with <code>expr is C</code>.</li> <li>If an alternative evaluates to <code>true</code>, then its <code>= alternative;</code> body is used as the value of the entire <code>inspect</code> expression, and the meaning is the same as if the entire <code>inspect</code> expression had been written as just <code>:Type = alternative;</code> \u2014 i.e., an unnamed object expression (aka 'temporary object') of type <code>Type</code> initialized with <code>alternative</code>.</li> <li>A catchall <code>is _</code> is required.</li> </ul> <p>For example:</p> Example: Using inspect<pre><code>//  A generic function that takes an argument 'x' of any type\n//  and inspects various things about `x`\ntest: (x) = {\n    forty_two := 42;\n    std::cout &lt;&lt; inspect x -&gt; std::string {\n        is 0           = \"zero\";            // == 0\n        is (forty_two) = \"the answer\";      // == 42\n        is int         = \"integer\";         // is type int (and not 0 or 42)\n        is std::string = x as std::string;  // is type std::string\n        is std::vector = \"a std::vector\";   // is a vector&lt;/*of-some-type*/&gt;\n        is _           = \"(no match)\";      // is something else\n    } &lt;&lt; \"\\n\";\n}\n\n//  Sample call site\ntest(42);\n    //  Behaves as if the following function were called:\n    //      test: (x) = { std::cout &lt;&lt; (:std::string = \"the answer\") &lt;&lt; \"\\n\"; }\n    //  (and that's why inspect alternatives are introduced with '=')\n</code></pre> <p>For more examples, see also the examples in the previous two sections on <code>is</code> and <code>as</code>, many of which use <code>inspect</code>.</p>"},{"location":"cpp2/expressions/#captures-including-interpolations","title":"<code>$</code> \u2014 captures, including interpolations","text":"<p>TODO</p> <p>For details, see Design note: Capture.</p>"},{"location":"cpp2/functions-and-variables/","title":"Functions","text":""},{"location":"cpp2/functions-and-variables/#overview","title":"Overview","text":"<p>TODO</p>"},{"location":"cpp2/functions-and-variables/#parameter-passing","title":"Parameter passing","text":"<p>TODO</p> <p>All parameters and other objects in Cpp2 are <code>const</code> by default, except for local variables. For details, see Design note: <code>const</code> objects by default.</p>"},{"location":"cpp2/functions-and-variables/#control-flow","title":"Control flow","text":""},{"location":"cpp2/functions-and-variables/#if-else-branches","title":"<code>if</code>, <code>else</code> \u2014 Branches","text":"<p>TODO</p>"},{"location":"cpp2/functions-and-variables/#for-while-do-loops","title":"<code>for</code>, <code>while</code>, <code>do</code> \u2014 Loops","text":"<p>TODO</p> <p>Loops can be named using the usual name <code>:</code> name introduction syntax, and <code>break</code> and <code>continue</code> can refer to those names. For example:</p> Example: Writing a simple type<pre><code>outer: while i&lt;M next i++ {      // loop named \"outer\"\n    // ...\n    inner: while j&lt;N next j++ {  // loop named \"inner\"\n        // ...\n        if something() {\n            continue inner;      // continue the inner loop\n        }\n        // ...\n        if something_else() {\n            break outer;         // break the outer loop\n        }\n        // ...\n    }\n    // ...\n}\n</code></pre>"},{"location":"cpp2/functions-and-variables/#unnamed-function-expressions-aka-lambdas","title":"Unnamed function expressions (aka lambdas)","text":"<p>TODO</p>"},{"location":"cpp2/functions-and-variables/#moveforward-from-last-use","title":"Move/forward from last use","text":"<p>TODO</p>"},{"location":"cpp2/functions-and-variables/#generality-unifying-functions-and-local-scopes","title":"Generality: Unifying functions and local scopes","text":"<p>TODO</p>"},{"location":"cpp2/metafunctions/","title":"Metafunctions","text":"<p>A metafunction is a compile-time function that can participate in interpreting the meaning of a declaration, and can:</p> <ul> <li> <p>apply defaults (e.g., <code>interface</code> makes functions virtual by default)</p> </li> <li> <p>enforce constraints (e.g., <code>value</code> enforces that the type has no virtual functions)</p> </li> <li> <p>generate additional functions and other code (e.g., <code>value</code> generates copy/move/comparison operations for a type if it didn't write them explicitly)</p> </li> </ul> <p>The most important thing about metafunctions is that they are not hardwired language features \u2014 they are compile-time library code that uses the reflection and code generation API, that lets the author of an ordinary type easily opt into a named set of defaults, requirements, and generated contents. This approach is essential to making the language simpler, because it lets us avoid hardwiring special \"extra\" types into the language and compiler.</p>"},{"location":"cpp2/metafunctions/#applying-metafunctions","title":"Applying metafunctions","text":"<p>Metafunctions provide an easy way for a type author to opt into a group of defaults, constraints, and generated functions: Just write <code>@name</code> afer the <code>:</code> of a declaration, where <code>name</code> is the name of the metafunctions. This lets the type author declare (and the human reader see) the intent up front: \"This isn't just any <code>type</code>, this is a <code>@value type</code>\" which automatically gives the type default/copy/move construction and assignment, <code>&lt;=&gt;</code> with <code>std::strong_ordering</code> comparisons, and guarantees that it has a public destructor and no protected or virtual functions:</p> Example: Using the value metafunction when writing a type<pre><code>point2d: @value type = {\n    x: i32 = 0;\n    y: i32 = 0;\n    // @value automatically generates default/copy/move\n    // construction/assignment and &lt;=&gt; strong_ordering comparison,\n    // and emits an error if you try to write a non-public\n    // destructor or any protected or virtual function\n}\n</code></pre>"},{"location":"cpp2/metafunctions/#generating-source-code-at-compile-time","title":"Generating source code at compile time","text":"<p>TODO</p>"},{"location":"cpp2/metafunctions/#built-in-metafunctions","title":"Built-in metafunctions","text":"<p>The following metafunctions are provided in the box with cppfront.</p>"},{"location":"cpp2/metafunctions/#interface","title":"interface","text":"<p>TODO</p>"},{"location":"cpp2/metafunctions/#polymorphic_base","title":"polymorphic_base","text":"<p>TODO</p>"},{"location":"cpp2/metafunctions/#ordered-weakly_ordered-partially_ordered","title":"ordered, weakly_ordered, partially_ordered","text":"<p>TODO</p>"},{"location":"cpp2/metafunctions/#copyable","title":"copyable","text":"<p>TODO</p>"},{"location":"cpp2/metafunctions/#basic_value-value-weakly_ordered_value-partially_ordered_value","title":"basic_value, value, weakly_ordered_value, partially_ordered_value","text":"<p>TODO</p>"},{"location":"cpp2/metafunctions/#struct","title":"struct","text":"<p>TODO</p>"},{"location":"cpp2/metafunctions/#enum-flag_enum","title":"<code>enum</code>, <code>flag_enum</code>","text":"<p>Cpp2 has no <code>enum</code> feature hardwired into the language. Instead you apply the <code>@enum</code> metafunction when writing an ordinary <code>type</code>:</p> Example: Using @enum<pre><code>// skat_game is declaratively a safe enumeration type: it has\n// default/copy/move construction/assignment and &lt;=&gt; with\n// std::strong_ordering, a minimal-size signed underlying type\n// by default if the user didn't specify a type, no implicit\n// conversion to/from the underlying type, in fact no public\n// construction except copy construction so that it can never\n// have a value different from its listed enumerators, inline\n// constexpr enumerators with values that automatically start\n// at 1 and increment by 1 if the user didn't write their own\n// value, and conveniences like to_string()... the word \"enum\"\n// carries all that meaning as a convenient and readable\n// opt-in, without hardwiring \"enum\" specially into the language\n//\nskat_game: @enum&lt;i16&gt; type = {\n    diamonds := 9;\n    hearts;  // 10\n    spades;  // 11\n    clubs;   // 12\n    grand    := 20;\n    null     := 23;\n}\n</code></pre> <p>Consider <code>hearts</code>: It's a member object declaration, but it doesn't have a type (or a default value) which is normally illegal, but here it's okay because the <code>@enum&lt;i16&gt;</code> metafunction fills them in: It iterates over all the data members and gives each one the underlying type (here explicitly specified as <code>i16</code>, otherwise it would be computed as the smallest signed type that's big enough), and an initializer (by default one higher than the previous enumerator).</p> <p>Unlike C <code>enum</code>, this <code>@enum</code> is scoped and strongly typed (does not implicitly convert to the underlying type.</p> <p>Unlike C++11 <code>enum class</code>, it's \"just a <code>type</code>\" which means it can naturally also have member functions and other things that a type can have:</p> Example: An @enum type with a member function<pre><code>janus: @enum type = {\n    past;\n    future;\n\n    flip: (inout this) == {\n        if this == past { this = future; }\n        else { this = past; }\n    }\n}\n</code></pre> <p>There's also a <code>flag_enum</code> variation with power-of-two semantics and an unsigned underlying type:</p> Example: Using @flag_enum<pre><code>// file_attributes is declaratively a safe flag enum type:\n// same as enum, but with a minimal-size unsigned underlying\n// type by default, and values that automatically start at 1\n// and rise by powers of two if the user didn't write their\n// own value, and bitwise operations plus .has(flags),\n// .set(flags), and .clear(flags)... the word \"flag_enum\"\n// carries all that meaning as a convenient and readable\n// opt-in without hardwiring \"[Flags]\" specially into the\n// language\n//\nfile_attributes: @flag_enum&lt;u8&gt; type = {\n    cached;     // 1\n    current;    // 2\n    obsolete;   // 4\n    cached_and_current := cached | current;\n}\n</code></pre>"},{"location":"cpp2/metafunctions/#union","title":"<code>union</code>","text":"<p><code>@union</code> declaratively opts into writing a safe discriminated union/variant dynamic type. For example:</p> Example: Using @union<pre><code>// name_or_number is declaratively a safe union/variant type:\n// it has a discriminant that enforces only one alternative\n// can be active at a time, members always have a name, and\n// each member has .is_member() and .member() accessors...\n// the word \"union\" carries all that meaning as a convenient\n// and readable opt-in without hardwiring \"union\" specially\n// into the language\n//\nname_or_number: @union type = {\n    name: std::string;\n    num : i32;\n}\n\nmain: () = {\n    x: name_or_number = ();\n\n    x.set_name(\"xyzzy\");            // now x is a string\n    std::cout &lt;&lt; x.name();          // prints the string\n\n    // trying to use x.num() here would cause a Type safety\n    // contract violation, because x is currently a string\n\n    x.set_num( 120 );               // now x is a number\n    std::cout &lt;&lt; x.num() + 3;       // prints 123\n}\n</code></pre> <p>Unlike C <code>union</code>, this <code>@union</code> is safe to use because it always ensures only the active type is accessed.</p> <p>Unlike C++11 <code>std::variant</code>, this <code>@union</code> is easier to use because its alternatives are anonymous, and safer to use because each union type is a distinct type. <sup>1</sup></p> <p>Each <code>@union</code> type has its own type-safe name, has clear and unambiguous named members, and safely encapsulates a discriminator to rule them all. Sure, it uses unsafe casts in the implementation, but they are fully encapsulated, where they can be tested once and be safe in all uses.</p> <p>Because a <code>@union type</code> is still a <code>type</code>, it can naturally have other things normal types can have, such as template parameter lists and member functions:</p> Example: A templated custom safe union type<pre><code>name_or_other: @union &lt;T:type&gt; type\n= {\n    name  : std::string;\n    other : T;\n\n    // a custom member function\n    to_string: (this) -&gt; std::string = {\n        if is_name()       { return name(); }\n        else if is_other() { return other() as std::string; }\n        else               { return \"invalid value\"; }\n    }\n}\n\nmain: () = {\n    x: name_or_other&lt;int&gt; = ();\n    x.set_other(42);\n    std::cout &lt;&lt; x.other() * 3.14 &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; x.to_string(); // prints \"42\" here, but is legal\n                                // whichever alternative is active\n}\n</code></pre>"},{"location":"cpp2/metafunctions/#cpp1_rule_of_zero","title":"cpp1_rule_of_zero","text":"<p>TODO</p>"},{"location":"cpp2/metafunctions/#print","title":"print","text":"<p>TODO</p>"},{"location":"cpp2/metafunctions/#writing-your-own-metafunctions","title":"Writing your own metafunctions","text":"<p>TODO</p>"},{"location":"cpp2/metafunctions/#reflection-api-reference","title":"Reflection API reference","text":"<p>TODO</p> <ol> <li> <p>With <code>variant</code>, there's no way to distinguish in the type system between a <code>variant&lt;int,string&gt;</code> that stores either an employee id or employee name, and a <code>variant&lt;int,string&gt;</code> that stores either a lucky number or a pet unicorn's dominant color.\u00a0\u21a9</p> </li> </ol>"},{"location":"cpp2/modules/","title":"Modules","text":""},{"location":"cpp2/modules/#overview","title":"Overview","text":"<p>TODO</p>"},{"location":"cpp2/modules/#import","title":"<code>import</code>","text":"<p>TODO</p>"},{"location":"cpp2/modules/#export","title":"<code>export</code>","text":"<p>TODO</p>"},{"location":"cpp2/namespaces/","title":"Namespaces","text":""},{"location":"cpp2/namespaces/#overview","title":"Overview","text":"<p>TODO</p> <p>For details, see Design note: Namespaces.</p>"},{"location":"cpp2/namespaces/#using","title":"<code>using</code>","text":"<p>TODO</p>"},{"location":"cpp2/objects/","title":"Objects, initialization, and memory","text":""},{"location":"cpp2/objects/#overview","title":"Overview","text":"<p>An object can be declared at any scope: in a namespace, in a <code>type</code>, in a function, in an expression.</p> <p>Its declaration is written using the same name <code>:</code> kind <code>=</code> value declaration syntax as everything in Cpp2:</p> <ul> <li> <p>name starts with a letter and is followed by other letters, digits, or <code>_</code>. Examples: <code>count</code>, <code>skat_game</code>, <code>Point2D</code> are valid names.</p> </li> <li> <p>kind is the object's type. In most places, except type scopes, you can write the <code>_</code> wildcard as the type (or omit the type entirely) to ask for the type to be deduced. When the type is a template and the templated arguments can be inferred from the constructor (via CTAD).</p> </li> <li> <p>value is the object's initial value. To use the default-constructed value, write <code>()</code>.</p> </li> </ul> <p>For example:</p> Example: Declaring some objects<pre><code>//  numbers is an object of type std::vector&lt;point2d&gt;,\n//  defined as having the initial contents 1, 2, 3\nnumbers: std::vector&lt;int&gt; = (1, 2, 3);\nnumbers: std::vector = (1, 2, 3);       // same, deducing the vector's type\n\n//  count is an object of type int, defined as having initial value -1\ncount: int = -1;\ncount: _ = -1;      // same, deducing the object's type with the _ wildcard\ncount := -1;        // same, deducing the object's type by just omitting it\n</code></pre>"},{"location":"cpp2/objects/#heap-objects","title":"Heap objects","text":"<p>Objects can also be allocated on the heap using <code>arena.new &lt;T&gt; (/*initializer, arguments)</code> where <code>arena</code> is any object that acts as a memory arena and provides a <code>.new</code> function template. Two memory arena objects are provided in namespace <code>cpp2</code>:</p> <ul> <li> <p><code>unique.new&lt;T&gt;</code> calls <code>std::make_unique</code> and returns a <code>std::unique_ptr</code>.</p> </li> <li> <p><code>shared.new&lt;T&gt;</code> calls <code>std::make_shared</code> and returns a <code>std::shared_ptr</code>.</p> </li> </ul> <p>The default is <code>unique.new</code> if you don't specify an arena object.</p> <p>For example (see types for more details about writing types):</p> Example: Heap allocation<pre><code>f: () -&gt; std::shared_ptr&lt;widget&gt;\n= {\n    //  Dynamically allocate an object owned by a std::unique_ptr\n    //  'vec' is a unique_ptr&lt;vector&lt;i32&gt;&gt; containing three values\n    vec := new&lt;std::vector&lt;i32&gt;&gt;(1, 2, 3);\n        // shorthand for 'unique.new&lt;...&gt;(...)'\n    std::cout &lt;&lt; vec*.ssize();  // prints 3\n\n    //  Dynamically allocate an object with shared ownership\n    wid := cpp2::shared.new&lt;widget&gt;();\n    store_a_copy( wid );        // store a copy of 'wid' somewhere\n    return wid;                 // and move-return a copy too\n\n} // as always in C++, vec is destroyed here automatically, which\n  // destroys the heap vector and deallocates its dynamic memory\n</code></pre>"},{"location":"cpp2/objects/#guaranteed-initialization","title":"Guaranteed initialization","text":"<p>TODO</p>"},{"location":"cpp2/types/","title":"Types","text":""},{"location":"cpp2/types/#overview","title":"Overview","text":"<p>A user-defined <code>type</code> is written using the same name <code>:</code> kind <code>=</code> value declaration syntax as everything in Cpp2. The type's \"value\" is a <code>{}</code>-enclosed body containing more declarations.</p> <p>In a <code>type</code>, data members are private by default, and functions and nested types are public by default. To explicitly declare a type scope declaration <code>public</code>, <code>protected</code>, or <code>private</code>, write that keyword at the beginning of the declaration.</p> Example: Writing a simple type<pre><code>mytype: type =\n{\n    // data members are private by default\n    x: std::string;\n\n    // functions are public by default\n    protected f: (this) = { do_something_with(x); }\n\n    // ...\n}\n</code></pre>"},{"location":"cpp2/types/#this-the-parameter-name","title":"<code>this</code> \u2014 The parameter name","text":"<p><code>this</code> is a synonym for the current object. Inside the scope of a type that has a member named <code>member</code>, <code>member</code> by default means <code>this.member</code>.</p> <p>Note: In Cpp2, <code>this</code> is not a pointer.</p> <p>The name <code>this</code> may only be used for the first parameter of a type-scope function (aka member function). It is never declared with an explicit <code>: its_type</code> because its type is always the current type.</p> <p><code>this</code> can be an <code>in</code> (default), <code>inout</code>, <code>out</code>, or <code>move</code> parameter. Which you choose naturally determines what kind of member function is being declared:</p> <ul> <li> <p><code>in this</code>: Writing <code>myfunc: (this /*...*/)</code>, which is shorthand for <code>myfunc: (in this /*...*/)</code>, defines a Cpp1 <code>const</code>-qualified member function, because  <code>in</code> parameters are <code>const</code>.</p> </li> <li> <p><code>inout this</code>: Writing <code>myfunc: (inout this /*...*/)</code> defines a Cpp1 non-<code>const</code> member function.</p> </li> <li> <p><code>out this</code>: Writing <code>myfunc: (out this /*...*/)</code> defines a Cpp1 constructor... and more. (See below.)</p> </li> <li> <p><code>move this</code>: Writing <code>myfunc: (move this /*...*/)</code> defines a Cpp1 <code>&amp;&amp;</code>-qualified member function, or if there are no additional parameters it defines the destructor.</p> </li> </ul> <p>For example, here is how to write read-only member function named <code>print</code> that takes a read-only string value and prints this object's data value and the string message:</p> Example: this<pre><code>mytype: type = {\n    data: i32;   // some data member (private by default)\n\n    print: (this, msg: std::string) = {\n        std::cout &lt;&lt; data &lt;&lt; msg;\n                 // \"data\" is shorthand for \"this.data\"\n    }\n\n    // ...\n}\n</code></pre>"},{"location":"cpp2/types/#this-inheritance","title":"<code>this</code> \u2014 Inheritance","text":"<p>Base types are written as members named this. For example, just as a type could write a data member as <code>data: string = \"xyzzy\";</code>, which is pronounced \"<code>data</code> is a <code>string</code> defined as having the default value <code>\"xyzzy\"</code>, a base type is written as <code>this: Shape = (default, values);</code>, which is pronounced \"<code>this</code> is a <code>Shape</code> defined as having these default values.\"</p> <p>Cpp2 syntax has no separate base list or separate member initializer list.</p> <p>Because base and member subobjects are all declared in the same place (the type body) and initialized in the same place (an <code>operator=</code> function body), they can be written in any order, including interleaved, and are still guaranteed to be safely initialized in declared order. This means that in Cpp2 you can declare a data member object before a base subobject, so that it naturally outlives the base subobject.</p> <p>Cpp2 code doesn't need workarounds like Boost's <code>base_from_member</code>, because all of the motivating examples for that can be written directly. See this explanation for details.</p>"},{"location":"cpp2/types/#virtual-override-and-final-virtual-functions","title":"<code>virtual</code>, <code>override</code>, and <code>final</code> \u2014 Virtual functions","text":"<p>A <code>this</code> parameter can additionally be declared as one of the following:</p> <ul> <li> <p><code>virtual</code>: Writing <code>myfunc: (virtual this /*...*/)</code> defines a new virtual function.</p> </li> <li> <p><code>override</code>: Writing <code>myfunc: (override this /*...*/)</code> defines an override of an existing base class virtual function.</p> </li> <li> <p><code>final</code>: Writing <code>myfunc: (final this /*...*/)</code> defines a final override of an existing base class virtual function.</p> </li> </ul> <p>A pure virtual function is a function with a <code>virtual this</code> parameter and no body.</p> <p>For example:</p> Example: Virtual functions<pre><code>abstract_base: type\n= {\n    //  A pure virtual function: virtual + no body\n    print: (virtual this, msg: std::string);\n\n    // ...\n}\n\nderived: type\n= {\n    //  'this' is-an 'abstract_base'\n    this: abstract_base;\n\n    //  Explicit override\n    print: (override this, msg: std::string);\n\n    // ...\n}\n</code></pre>"},{"location":"cpp2/types/#implicit-controlling-conversion-functions","title":"<code>implicit</code> \u2014 Controlling conversion functions","text":"<p>A <code>this</code> parameter of an <code>operator=</code> function can additionally be declared as:</p> <ul> <li><code>implicit</code>: Writing <code>operator=: (implicit out this, /*...*/)</code> defines a function that will not be marked as \"explicit\" when lowered to Cpp1 syntax.</li> </ul> <p>Note: This reverses the Cpp1 default, where constructors are not \"explicit\" by default, and you have to write \"explicit\" to make them explicit.</p>"},{"location":"cpp2/types/#operator-construction-assignment-and-destruction","title":"<code>operator=</code> \u2014 Construction, assignment, and destruction","text":"<p>All value operations are spelled <code>operator=</code>, including construction, assignment, and destruction. <code>operator=</code> sets the value of <code>this</code> object, so the <code>this</code> parameter can be pass as anything but <code>in</code> (which would imply <code>const</code>):</p> <ul> <li> <p><code>out this</code>: Writing <code>operator=: (out this /*...*/ )</code> is naturally both a constructor and an assignment operator, because an <code>out</code> parameter can take an uninitialized or initialized argument. If you don't write a more-specialized <code>inout this</code> assignment operator, Cpp2 will use the <code>out this</code> function also for assignment.</p> </li> <li> <p><code>inout this</code>: Writing <code>operator=: (inout this /*...*/ )</code> is an assignment operator (only), because an <code>inout</code> parameter requires an initialized modifiable argument.</p> </li> <li> <p><code>move this</code>: Writing <code>operator=: (move this)</code> is the destructor. No other parameters are allowed, so it connotes \"move <code>this</code> nowhere.\"</p> </li> </ul> <p>Unifying <code>operator=</code> enables usable <code>out</code> parameters, which is essential for composable guaranteed initialization. We want the expression syntax <code>x = value</code> to be able to call a constructor or an assignment operator, so naming them both <code>operator=</code> is consistent.</p> <p>Note: Writing <code>=</code> always invokes an <code>operator=</code> (in fact for a Cpp2-authored type, and semantically for a Cpp1-authored type). This avoids the Cpp1 inconsistency that \"writing <code>=</code> calls <code>operator=</code>, except when it doesn't\" (such as in a Cpp1 variable initialization). Conversely, <code>operator=</code> is always invoked by <code>=</code> in Cpp2.</p>"},{"location":"cpp2/types/#that-a-source-parameter","title":"<code>that</code> \u2014 A source parameter","text":"<p>All functions can have a <code>that</code> is a synonym for the object to be copied/moved from. Like <code>this</code>, at type scope it is never declared with an explicit <code>: its_type</code> because its type is always the current type.</p> <p><code>that</code> can be an <code>in</code> (default) or <code>move</code> parameter. Which you choose naturally determines what kind of member function is being declared:</p> <ul> <li> <p><code>in that</code>: Writing <code>myfunc: (/*...*/ this, that)</code>, which is shorthand for <code>myfunc: (/*...*/ this, in that)</code>, is naturally both a copy and move function, because it can accept an lvalue or an rvalue <code>that</code> argument. If you don't write a more-specialized <code>move that</code> move function, Cpp2 will automatically use the <code>in that</code> function also for move.</p> </li> <li> <p><code>move that</code>: Writing <code>myfunc: (/*...*/ this, move that)</code> defines a move function.</p> </li> </ul> <p>Putting <code>this</code> and <code>that</code> together: The most general form of <code>operator=</code> is <code>operator=: (out this, that)</code>. It works as a unified general {copy, move} x { constructor, assignment } operator, and generates all of four of those in the lowered Cpp1 code if you didn't write a more specific one yourself.</p>"},{"location":"cpp2/types/#operator-can-generalize-assignment-from-construction-and-move-from-copy","title":"<code>operator=</code> can generalize (A)ssignment from construction, and (M)ove from copy","text":"<p>As mentioned above: - If you don't write an <code>inout this</code> function, Cpp2 will use your <code>out this</code> function in its place (if you wrote one). - If you don't write a <code>move that</code> function, Cpp2 will use your <code>in that</code> function in its place (if you wrote one).</p> <p>Note: When lowering to Cpp1, this just means generating the applicable special member functions from the appropriate Cpp2 function.</p> <p>This graphic summarizes these generalizations. For convenience I've numbered the (A)ssignment and (M)ove defaults.</p> <p></p> <p>In Cpp1 terms, they can be described as follows:</p> <ul> <li> <p>(M)ove, M1, M2: If you write a copy constructor or assignment operator, but not a corresponding move constructor or assignment operator, the latter is generated.</p> </li> <li> <p>(A)ssignment, A1, A2, A3: If you write a copy or move or converting constructor, but not a corresponding copy or move or converting assignment operator, the latter is generated.</p> </li> <li> <p>The arrows are transitive. For example, if you write a copy constructor and nothing else, the move constructor, copy assignment operator, and move assignment operator are generated.</p> </li> <li> <p>M2 is preferred over A2. Both M2 and A2 can generate a missing <code>(inout this, move that)</code> function. If both options are available, Cpp2 prefers to use M2 (generate move assignment from copy assignment, which could itself have been generated from copy construction) rather than A2 (generate move assignment from move construction). This is because M2 is a better fit: Move assignment is more like copy assignment than like move construction, because assignments are designed structurally to set the value of an existing <code>this</code> object.</p> </li> </ul> <p>The most general <code>operator=</code> with <code>that</code> is <code>(out this, that)</code>. In Cpp1 terms, it generates all four combinations of { copy, move } x { constructor, assignment }. This is often sufficient, so you can write all these value-setting just once. If you do want to write a more specific version that does something else, though, you can always write it too.</p> <p>Note: Generating <code>inout this</code> (assignment) from <code>out this</code> also generates converting assignment from converting construction, which is a new thing. Today in Cpp1, if you write a converting constructor from another type <code>X</code>, you may or may not write the corresponding assignment from <code>X</code>; in Cpp2 you will get that by default, and it sets the object to the same state as the converting constructor from <code>X</code> does.</p>"},{"location":"cpp2/types/#minimal-functions-generated-by-default","title":"Minimal functions generated by default","text":"<p>There are only two defaults the language will generate implicitly for a type:</p> <ul> <li> <p>The only special function every type must have is the destructor. If you don't write it by hand, a public nonvirtual destructor is generated by default.</p> </li> <li> <p>If no <code>operator=</code> functions are written by hand, a public default constructor is generated by default.</p> </li> </ul> <p>All other <code>operator=</code> functions are explicitly written, either by hand or by opting into applying a metafunction (see below).</p> <p>Note: Because generated functions are always opt-in, you can never get a generated function that's wrong for your type, and so Cpp2 doesn\u2019t need to support \"=delete\" for the purpose of suppressing unwanted generated functions.</p>"},{"location":"cpp2/types/#memberwise-by-default","title":"Memberwise by default","text":"<p>All copy/move/comparison <code>operator=</code> functions are memberwise by default in Cpp2. That includes when you write memberwise construction and assignment yourself. In a hand-written <code>operator=</code>:</p> <ul> <li> <p>The body must begin with a series of <code>member = value;</code> statements, one for each of the type's data members in order.</p> </li> <li> <p>If the body does not mention a member, by default the member's default initializer is used.</p> </li> <li> <p>In an assignment operator (<code>inout this</code>), you an explicitly skip setting a member by writing <code>member = _;</code> where it would normally be set, if you know you have a reason to set its value later instead.</p> </li> </ul> <p>For example:</p> <p>``` cpp title=\"Memberwise operator= semantics mytype: type = {     //  data members (private by default)     name:          std::string;     social_handle: std::string = \"(unknown)\";</p> <pre><code>//  conversion from string\noperator=: (out this, who: std::string) = {\n    name = who;\n    //  if social_handle is not mentioned, defaults to:\n    //      social_handle = \"(unknown)\";\n\n    //  now that the members have been set,\n    //  any other code can follow...\n    print();\n}\n\n//  copy/move constructor/assignment\noperator=: (out this, that) = {\n    //  if neither data member is mentioned, defaults to:\n    //      name = that.name;\n    //      social_handle = that.social_handle;\n    print();\n}\n\nprint: (this) = std::cout &lt;&lt; \"value is [(name)$] [(social_handle)$]\\n\";\n</code></pre> <p>}</p> <p>//  The above definition of mytype allows all of the following... main: () = {     x: mytype = \"Jim\"; // construct from string     x = \"John\";        // assign from string     y := x;            // copy construct     y = x;             // copy assign     z := (move x);     // move construct     z = (move y);      // move assign     x.print();         // [] [] - moved from     y.print();         // [] [] - moved from } ```</p> <p>Note: This makes memberwise semantics symmetric for construction and assignment. In Cpp1, only non-copy/move constructors have a default, which is to initialize a member with its default initializer. In Cpp2, both constructors and assignment operators default to using the default initializer for if it's a conversion function (non-<code>that</code>, aka non-copy/move), and using memberwise <code>member = that.member;</code> for copy/move functions.</p>"},{"location":"cpp2/types/#operator-unified-comparisons","title":"<code>operator&lt;=&gt;</code> \u2014 Unified comparisons","text":"<p>Most of Cpp2's <code>operator&lt;=&gt;</code> has already been merged into ISO C++, except for allowing chained comparisons. In Cpp2, comparisons can be safely chained, and always have the mathematically sound transitive meaning or else are rejected at compile time:</p> <ul> <li> <p>Valid chains: All <code>&lt;</code>/<code>&lt;=</code>, all <code>&gt;</code>/<code>&gt;=</code>, or all <code>==</code>. All mathematically sound and safe chains like <code>a &lt;= b &lt; c</code> are supported, with efficient single evaluation of each term. They are \"sound\" because they are transitive; these chains imply a relationship between <code>a</code> and <code>c</code> (in this case, the chain implies that <code>a &lt;= c</code> is also true).</p> </li> <li> <p>Invalid chains: Everything else. Nonsense chains like <code>a &gt;= b &lt; c</code> and <code>a != b != c</code> are compile time errors. They are \"nonsense\" because they are non-transitive; these chains do not imply any relationship between <code>a</code> and <code>c</code>.</p> </li> </ul> <p>For details, see P0515 \"Consistent comparison\" section 3.3 and P0893 \"Chaining comparisons\".</p>"},{"location":"cppfront/mixed/","title":"Mixing Cpp1 (today's C++) and Cpp2 in the same source file","text":""},{"location":"cppfront/mixed/#compiling-a-source-file-that-contains-both-cpp1-and-cpp2-code","title":"Compiling a source file that contains both Cpp1 and Cpp2 code","text":"<p>Cppfront compiles a <code>.cpp2</code> file and produces a <code>.cpp</code> file to be compiled by your favorite C++20 or higher C++ compiler.</p> <p>The same <code>.cpp2</code> file may contain both Cpp2 syntax and today's \"Cpp1\" C++ syntax, side by side but not nested.</p> <p>When cppfront compiles such a mixed file, it just passes through the Cpp1 code as-is, and translates the Cpp2 code to Cpp1 in-place. This means that when a call site (call this the \"caller\") uses a type/function/object (call this the \"callee\") written in the same file:</p> <ul> <li> <p>Code written in all Cpp2 is always order-independent by default. When a caller written in Cpp2 syntax uses a callee written in Cpp2 syntax, they can appear in either order in the file.</p> </li> <li> <p>Code written in Cpp1 is order-dependent as usual. When either the caller or the callee (or both) are written in Cpp1 syntax, the callee must be declared before the caller.</p> </li> </ul>"},{"location":"cppfront/mixed/#okay-cpp1-and-cpp2-side-by-side-interleaved","title":"Okay: Cpp1 and Cpp2 side by side, interleaved","text":"<p>For example, this source file is fine, where the Cpp2 and Cpp1 code are side by side and seamlessly call each other directly as usual:</p> mixed.cpp2  \u2014 Mixing Cpp1 and Cpp2 code side by side in the same source file is okay<pre><code>#include &lt;iostream&gt;                             // Cpp1\n#include &lt;string_view&gt;                          // Cpp1\n\nN: namespace = {                                        // Cpp2\n    hello: (msg: std::string_view) =                    // Cpp2\n        std::cout &lt;&lt; \"Hello, (msg)$!\\n\";                // Cpp2\n}                                                       // Cpp2\n\nint main() {                                    // Cpp1\n    auto words = std::vector{ \"Alice\", \"Bob\" }; // Cpp1\n    N::hello( words[0] );                       // Cpp1\n    N::hello( words[1] );                       // Cpp1\n    std::cout &lt;&lt; \"... and goodnight\\n\";         // Cpp1\n}                                               // Cpp1\n</code></pre>"},{"location":"cppfront/mixed/#not-allowed-nesting-cpp1-inside-cpp2-and-vice-versa","title":"Not allowed: Nesting Cpp1 inside Cpp2 (and vice versa)","text":"<p>However, the following source file is not valid, because it tries to nest Cpp2 code inside Cpp1 code, and vice versa:</p> ERROR.cpp2 \u2014 this is NOT allowed<pre><code>#include &lt;iostream&gt;                             // Cpp1\n#include &lt;string_view&gt;                          // Cpp1\n\nnamespace N {                                   // Cpp1\n    hello: (msg: std::string_view) =                    // Cpp2 (ERROR here)\n        std::cout &lt;&lt; \"Hello, (msg)$!\\n\";                // Cpp2 (ERROR here)\n}                                               // Cpp1\n\nmain: () = {                                            // Cpp2\n    auto words = std::vector{ \"Alice\", \"Bob\" }; // Cpp1 (ERROR here)\n    N::hello( words[0] );                           // ?\n    N::hello( words[1] );                           // ?\n    std::cout &lt;&lt; \"... and goodnight\\n\";             // ?\n}                                                       // Cpp2\n</code></pre> <p>The above nesting is not supported because it would create not just parsing problems but also semantic ambiguities. For example, lines 11-13 are syntactically valid as Cpp1 or as Cpp2, but if they are treated as Cpp2 then the <code>words[0]</code> and <code>words[1]</code> expressions' <code>std::vector::operator[]</code> calls are bounds-checked and bounds-safe by default, whereas if they are treated as Cpp1 then they are not bounds-checked. And that's a pretty important difference to be sure about!</p>"},{"location":"cppfront/options/","title":"Cppfront command line options","text":"<p>Cppfront is invoked using</p> <pre><code>cppfront [options] file ...\n</code></pre> <p>where</p> <ul> <li> <p>options is optional, and can include options described on this page</p> </li> <li> <p>file ... is a list of one or more <code>.cpp2</code> filenames to be compiled</p> </li> </ul> <p>Command line options are spelled starting with <code>-</code> or <code>/</code> followed by the option name. For example, <code>-help</code> prints help.</p> <p>For convenience, you can shorten the name to any unique prefix not shared with another option. For example:</p> <ul> <li><code>-help</code> can be equivalently written as <code>-hel</code>, <code>-he</code>, or <code>-h</code>, because no other option starts with <code>h</code>.</li> <li><code>-import-std</code> and <code>-include-std</code> can be shortened to <code>-im</code> and <code>-in</code> respectively, but not <code>-i</code> which would be ambiguous with each other.</li> </ul>"},{"location":"cppfront/options/#basic-command-line-options","title":"Basic command line options","text":""},{"location":"cppfront/options/#-help-h-","title":"<code>-help</code>, <code>-h</code>, <code>-?</code>","text":"<p>Prints an abbreviated version of this documentation page.</p>"},{"location":"cppfront/options/#-import-std-im","title":"<code>-import-std</code>, <code>-im</code>","text":"<p>Makes the entire C++ standard library (namespace <code>std::</code>) available via a module <code>import std.compat;</code> (which implies <code>import std;</code>).</p> <p>When you use either <code>-import-std</code> or <code>-include-std</code>, your <code>.cpp2</code> program will not need to explicitly <code>import</code> any C++ standard library module or <code>#include</code> any C++ standard library header (it can still do that, but it would be redundant).</p> <p>This option is implicitly set if <code>-pure-cpp2</code> is selected.</p> <p>This option is ignored if <code>-include-std</code> is selected. If your Cpp1 compiler does not yet support standard library modules <code>std</code> and <code>std.compat</code>, this option automatically uses  <code>-include-std</code> instead as a fallback.</p>"},{"location":"cppfront/options/#-include-std-in","title":"<code>-include-std</code>, <code>-in</code>","text":"<p>Makes the entire C++ standard library (namespace <code>std::</code>) available via an '#include\" of every standard header.</p> <p>This option should always work with all standard headers, including draft-standard C++26 headers that are not yet in a published standard, because it tracks new headers as they are added and uses feature tests to not include headers that are not yet available on your Cpp1 implementation.</p>"},{"location":"cppfront/options/#-pure-cpp2-p","title":"<code>-pure-cpp2</code>, <code>-p</code>","text":"<p>Allow Cpp2 syntax only.</p> <p>This option also sets <code>-import-std</code>.</p>"},{"location":"cppfront/options/#-version-vers","title":"<code>-version</code>, <code>-vers</code>","text":"<p>Print version, build, copyright, and license information.</p>"},{"location":"cppfront/options/#additional-dynamic-safety-checks-and-contract-information","title":"Additional dynamic safety checks and contract information","text":""},{"location":"cppfront/options/#-add-source-info-a","title":"<code>-add-source-info</code>, <code>-a</code>","text":"<p>Enable <code>source_location</code> information for contract checks. If this is supported by your Cpp1 compiler, the default contract failure messages will include exact file/line/function information. For example, if the default <code>Bounds</code> violation handler would print this without <code>-a</code>:</p> <pre><code>Bounds safety violation: out of bounds access attempt detected - attempted access at index 2, [min,max] range is [0,1]\n</code></pre> <p>then it would print something like this with <code>-a</code> (the exact text will vary with the Cpp1 standard library vendor's <code>source_location</code> implementation):</p> <pre><code>demo.cpp2(4) int __cdecl main(void): Bounds safety violation: out of bounds access attempt detected - attempted access at index 2, [min,max] range is [0,1]\n</code></pre>"},{"location":"cppfront/options/#-no-comparison-checks-no-c","title":"<code>-no-comparison-checks</code>, <code>-no-c</code>","text":"<p>Disable mixed-sign comparison safety checks. If not disabled, mixed-sign comparisons are diagnosed by default.</p>"},{"location":"cppfront/options/#-no-null-checks-no-n","title":"<code>-no-null-checks</code>, <code>-no-n</code>","text":"<p>Disable null safety checks. If not disabled, null dereference checks are performed by default.</p>"},{"location":"cppfront/options/#-no-subscript-checks-no-s","title":"<code>-no-subscript-checks</code>, <code>-no-s</code>","text":"<p>Disable subscript bounds safety checks. If not disabled, subscript bounds safety checks are performed by default.</p>"},{"location":"cppfront/options/#support-for-constrained-target-environments","title":"Support for constrained target environments","text":""},{"location":"cppfront/options/#-fno-exceptions-fno-e","title":"<code>-fno-exceptions</code>, <code>-fno-e</code>","text":"<p>Disable C++ exception handling. This should be used only if you must run in an environment that bans C++ exception handling, and so you are already using a similar command line option for your Cpp1 compiler.</p> <p>If this option is selected, a failed <code>as</code> for <code>std::variant</code> will assert.</p>"},{"location":"cppfront/options/#-fno-rtti-fno-r","title":"<code>-fno-rtti</code>, <code>-fno-r</code>","text":"<p>Disable C++ run-time type information (RTTI). This should be used only if you must run in an environment that bans C++ RTTI, and so you are already using a similar command line option for your Cpp1 compiler.</p> <p>If this option is selected, trying to using <code>as</code> for <code>*</code> (raw pointers) or <code>std::any</code> will assert.</p>"},{"location":"cppfront/options/#other-options","title":"Other options","text":""},{"location":"cppfront/options/#-clean-cpp1-c","title":"<code>-clean-cpp1</code>, <code>-c</code>","text":"<p>Emit clean <code>.cpp</code> files without <code>#line</code> directives and other extra information that cppfront normally emits in the <code>.cpp</code> to light up C++ tools (e.g., to let IDEs integrate cppfront error message output, debuggers step to the right lines in Cpp2 source code, and so forth). In normal use, you won't need <code>-c</code>.</p>"},{"location":"cppfront/options/#-debug-d","title":"<code>-debug</code>, <code>-d</code>","text":"<p>Emit compiler debug output. This is only useful when debugging cppfront itself.</p>"},{"location":"cppfront/options/#-emit-cppfront-info-e","title":"<code>-emit-cppfront-info</code>, <code>-e</code>","text":"<p>Emit cppfront version and build in the <code>.cpp</code> file.</p>"},{"location":"cppfront/options/#-format-colon-errors-fo","title":"<code>-format-colon-errors</code>, <code>-fo</code>","text":"<p>Emit cppfront diagnostics using <code>:line:col:</code> format for line and column numbers, if that is the format better recognized by your IDE, so that it will pick up cppfront messages and integrate them in its normal error message output location. If not set, by default cppfront diagnostics use <code>(line,col)</code> format.</p>"},{"location":"cppfront/options/#-line-paths-l","title":"<code>-line-paths</code>, <code>-l</code>","text":"<p>Emit absolute paths in <code>#line</code> directives.</p>"},{"location":"cppfront/options/#-output-filename-o-filename","title":"<code>-output</code> filename, <code>-o</code> filename","text":"<p>Output to 'filename' (can be 'stdout'). If not set, the default output filename for is the same as the input filename without the <code>2</code> (e.g., compiling <code>hello.cpp2</code> by default writes its output to <code>hello.cpp</code>, and <code>header.h2</code> to <code>header.h</code>).</p>"},{"location":"cppfront/options/#-verbose-verb","title":"<code>-verbose</code>, <code>-verb</code>","text":"<p>Print verbose statistics and <code>-debug</code> output.</p>"},{"location":"welcome/hello-world/","title":"Hello, world!","text":""},{"location":"welcome/hello-world/#a-hellocpp2-program","title":"A <code>hello.cpp2</code> program","text":"<p>Here is the usual one-line starter program that prints <code>Hello, world!</code>. Note that this is a complete program, no <code>#include</code> required:</p> hello.cpp2 \u2014 on one line<pre><code>main: () = std::cout &lt;&lt; \"Hello, world!\\n\";\n</code></pre> <p>But let's add a little more, just to show a few things:</p> hello.cpp2 \u2014 slightly more interesting<pre><code>main: () = {\n    words: std::vector = ( \"Alice\", \"Bob\" );\n    hello( words[0] );\n    hello( words[1] );\n    std::cout &lt;&lt; \"... and goodnight\\n\";\n}\n\nhello: (msg: std::string_view) =\n    std::cout &lt;&lt; \"Hello, (msg)$!\\n\";\n</code></pre> <p>This short program code already illustrates a few Cpp2 essentials.</p> <p>Consistent context-free syntax. Cpp2 is designed so that there is one general way to spell a given thing, that works consistently everywhere. All Cpp2 types/functions/objects/namespaces are written using the unambiguous and context-free declaration syntax \"name <code>:</code> kind <code>=</code> statement\". The <code>:</code> is pronounced \"is a,\" and the <code>=</code> is pronounced \"defined as.\"</p> <ul> <li> <p><code>main</code> is a function that takes no arguments and returns nothing, and is defined as the code body shown.</p> </li> <li> <p><code>words</code> is a <code>std::vector</code>, initially defined as holding <code>\"Alice\"</code> and <code>\"Bob\"</code>.</p> </li> <li> <p><code>hello</code> is a function that takes a <code>std::string_view</code> it will only read from and that returns nothing, and is defined as code that prints the string to <code>cout</code> the usual C++ way.</p> </li> </ul> <p>All grammar is context-free. In particular, we (the human reading the code, and the compiler) never need to do name lookup to figure out how to parse something \u2014 there is never a \"vexing parse\" in Cpp2. For details, see Design note: Unambiguous parsing.</p> <p>Simple, safe, and efficient by default. Cpp2 has contracts (tracking draft C++26 contracts), <code>inspect</code> pattern matching, string interpolation, automatic move from last use, and more.</p> <p></p> <ul> <li> <p>Declaring <code>words</code> uses \"CTAD\" (C++'s normal constructor template argument deduction) to declare its <code>words</code> variable.</p> </li> <li> <p>Calling <code>words[0]</code> and <code>words[1]</code> is bounds-checked by default. From Cpp2 code, ordinary <code>std::vector</code> subscript accesses are safely bounds-checked by default without requiring any upgrade to your favorite standard library, and that's true for any similar subscript of something whose size can be queried using <code>std::size()</code>, including any in-house integer-indexed container types you already have that can easily provide <code>std::size()</code> if they don't already.</p> </li> <li> <p><code>hello</code> uses string interpolation to be able to write <code>\"Hello, (msg)$!\\n\"</code> instead of <code>\"Hello, (\" &lt;&lt; msg &lt;&lt; \"!\\n\"</code>.</p> </li> </ul> <p>Simplicity through generality + defaults. A major way that Cpp2 delivers simplicity is by providing just one powerful general syntax for a given thing (e.g., one function definition syntax), but designing it so you can omit the parts you're not currently using (e.g., where you're happy with the defaults). We're already using some of those defaults above:</p> <ul> <li> <p>We can omit writing the <code>-&gt; void</code> return type for a function that doesn't return anything, as both of these functions do.</p> </li> <li> <p>We can omit the <code>{</code> <code>}</code> around single-statement function bodies, as <code>hello</code> does.</p> </li> <li> <p>We can omit the <code>in</code> on the <code>msg</code> parameter. Cpp2 has just six ways to pass parameters: The most common ones are <code>in</code> for read-only (the default so we can omit it, as <code>hello</code> does), <code>inout</code> for read-write, and also <code>copy</code>, <code>out</code>, <code>move</code>, and <code>forward</code>.</p> </li> </ul> <p>For details, see Design note: Defaults are one way to say the same thing.</p> <p>Order-independent by default. Did you notice that <code>main</code> called <code>hello</code>, which was defined later? Cpp2 code is order-independent by default \u2014 there are no forward declarations.</p> <p>Seamless compatibility and interop. We can just use <code>std::cout</code> and <code>std::operator&lt;&lt;</code> and <code>std::string_view</code> directly as usual. Cpp2 code works with any C++ code or library, including the standard library, using ordinary direct calls without any wrapping/marshaling/thunking.</p> <p>C++ standard library always available. We didn't need <code>#include &lt;iostream&gt;</code> or <code>import std;</code>. The full C++ standard library is always available by default if your source file contains only syntax-2 code and you compile using cppfront's <code>-p</code> (short for <code>-pure-cpp2</code>). Cppfront is regularly updated to be compatible with C++23 and the latest draft C++26 library additions as soon as the ISO C++ committee votes them into the C++26 working draft, so as soon as you have a C++ implementation that has a new standard (or bleeding-edge draft standard!) C++ library feature, you'll be able to fully use it in Cpp2 code.</p>"},{"location":"welcome/hello-world/#building-hellocpp2","title":"Building <code>hello.cpp2</code>","text":"<p>Now use <code>cppfront</code> to compile <code>hello.cpp2</code> to a standard C++ file <code>hello.cpp</code>:</p> Call cppfront to produce hello.cpp<pre><code>cppfront hello.cpp2 -p\n</code></pre> <p>The result is an ordinary C++ file that looks like this: <sup>1</sup></p> hello.cpp \u2014 created by cppfront<pre><code>#define CPP2_IMPORT_STD          Yes\n\n#include \"cpp2util.h\"\n\nauto main() -&gt; int;\n\nauto hello(cpp2::in&lt;std::string_view&gt; msg) -&gt; void;\nauto main() -&gt; int{\n    std::vector words {\"Alice\", \"Bob\"};\n    hello(CPP2_ASSERT_IN_BOUNDS_LITERAL(words, 0));\n    hello(CPP2_ASSERT_IN_BOUNDS_LITERAL(std::move(words), 1));\n    std::cout &lt;&lt; \"... and goodnight\\n\";\n}\n\nauto hello(cpp2::in&lt;std::string_view&gt; msg) -&gt; void {\n    std::cout &lt;&lt; (\"Hello, \" + cpp2::to_string(msg) + \"!\\n\");  }\n</code></pre> <p>Here we can see more of how Cpp2 makes it features work.</p> <p>How: Consistent context-free syntax.</p> <ul> <li>Lines 8, 9, and 15: Portable C++20 code we can build with any C++ compiler. Cpp2's context-free syntax converts directly to today's Cpp1 syntax. We can write and read our C++ types/functions/objects in simpler Cpp2 syntax without wrestling with context sensitivity and ambiguity, and they're all still just ordinary types/functions/objects.</li> </ul> <p>How: Simple, safe, and efficient by default.</p> <ul> <li>Line 9: CTAD just works, because it turns into ordinary C++ code which already supports CTAD.</li> <li>Lines 10-11: Automatic bounds checking is added to <code>words[0]</code> and <code>words[1]</code> nonintrusively at the call site by default. Because it's nonintrusive, it works seamlessly with all existing container types that are <code>std::ssize</code>-aware, when you use them from safe Cpp2 code.</li> <li>Line 11: Automatic move from last use ensures the last use of <code>words</code> will automatically avoid a copy if it's being passed to something that's optimized for rvalues.</li> <li>Line 16: String interpolation performs the string capture of <code>msg</code>'s current value via <code>cpp2::to_string</code>. That uses <code>std::to_string</code> when available, and it also works for additional types (such as <code>bool</code>, to print <code>false</code> and <code>true</code> instead of <code>0</code> and <code>1</code>, without having to remember to use <code>std::boolalpha</code>).</li> </ul> <p>How: Simplicity through generality + defaults.</p> <ul> <li>Line 7: <code>in</code> parameters are implemented using <code>cpp2::in&lt;&gt;</code>, which is smart enough to pass by <code>const</code> value when that's safe and appropriate, otherwise by <code>const&amp;</code>, so you don't have to choose the right one by hand.</li> </ul> <p>How: Order-independent by default.</p> <ul> <li>Lines 5 and 7: Order independence happens because cppfront generates all the type and function forward declarations for you, so you don't have to. That's why <code>main</code> can just call <code>hello</code>: Both are forward-declared, so they can both see each other.</li> </ul> <p>How: Seamless compatibility and interop.</p> <ul> <li>Lines 9, 12, and 16: Ordinary direct calls to existing C++ code, so there's never a need for wrapping/marshaling/thunking.</li> </ul> <p>How: C++ standard library always available.</p> <ul> <li>Lines 1 and 3: <code>std::</code> is available because cppfront was invoked with <code>-p</code>, which implies either <code>-im</code> (short for <code>-import-std</code>) or <code>-in</code> (short for <code>-include-std</code>, for compilers that don't support modules yet). The generated code tells <code>cpp2util.h</code> to <code>import</code> the entire standard library as a module (or do the equivalent via headers if modules are not available).</li> </ul>"},{"location":"welcome/hello-world/#building-and-running-hellocpp-with-any-recent-c-compiler","title":"Building and running <code>hello.cpp</code> with any recent C++ compiler","text":"<p>Finally, just build <code>hello.cpp</code> using your favorite C++20 compiler, where <code>CPPFRONT_INCLUDE</code> is the path to <code>/cppfront/include</code>:</p> <p> MSVC (Visual Studio 2019 version 16.11 or higher)<pre><code>&gt; cl hello.cpp -std:c++20 -EHsc -I CPPFRONT_INCLUDE\n&gt; hello.exe\nHello, world!\n</code></pre> GCC (GCC 10 or higher)<pre><code>$ g++ hello.cpp -std=c++20 -ICPPFRONT_INCLUDE -o hello\n$ ./hello.exe\nHello, world!\n</code></pre> Clang (Clang 12 or higher)<pre><code>$ clang++ hello.cpp -std=c++20 -ICPPFRONT_INCLUDE -o hello\n$ ./hello.exe\nHello, world!\n</code></pre>"},{"location":"welcome/hello-world/#next-adding-cppfront-to-your-existing-c-project","title":"\u27a4 Next: Adding cppfront to your existing C++ project","text":"<ol> <li> <p>For presentation purposes, this documentation generally shows the <code>.cpp</code> as generated when using cppfront's <code>-c</code> (short for <code>-clean-cpp1</code>), which suppresses extra information cppfront normally emits in the <code>.cpp</code> to light up C++ tools (e.g., to let IDEs integrate cppfront error message output, debuggers step to the right lines in Cpp2 source code, and so forth). In normal use, you won't need <code>-c</code>.\u00a0\u21a9</p> </li> </ol>"},{"location":"welcome/integration/","title":"Adding cppfront in your IDE / build system","text":"<p>To start trying out Cpp2 syntax in any existing C++ project, just add a build step to translate the Cpp2 to Cpp1 syntax:</p> <ul> <li>Add the <code>.cpp2</code> file to the project, and ensure the <code>.cpp</code> is in C++20 mode.</li> <li>Tell the IDE to build that file using a custom build tool to invoke cppfront.</li> </ul> <p>That's it... The result Just Works with every C++20 or higher compiler and all existing C++ tools (debuggers, build systems, sanitizers, etc.). The IDE build should just pick up the <code>.cpp2</code> file source locations for any error messages, and the debugger should just step through the <code>.cpp2</code> file.</p> <p>The following uses Visual Studio as an example, but others have done the same in Xcode, Qt Creator, CMake, and other IDEs.</p>"},{"location":"welcome/integration/#1-add-the-cpp2-file-to-the-project-and-ensure-the-cpp-is-in-c20-mode","title":"1. Add the <code>.cpp2</code> file to the project, and ensure the <code>.cpp</code> is in C++20 mode","text":"<p>For Visual Studio: In the Solution Explorer, right-click on Source Files and pick Add to add the file to the project.</p> <p></p> <p>Also in Solution Explorer, right-click on the <code>.cpp</code> file Properties and make sure it's in C++20 (or C++latest) mode.</p> <p></p>"},{"location":"welcome/integration/#2-tell-the-project-system-to-build-that-file-using-a-custom-build-tool-to-invoke-cppfront-and-add-cppfrontinclude-to-the-include-path","title":"2. Tell the project system to build that file using a custom build tool to invoke cppfront, and add <code>cppfront/include</code> to the include path","text":"<p>For Visual Studio: In Solution Explorer, right-click on the <code>.cpp2</code> file and select Properties, and add the custom build tool. Remember to also tell it that the custom build tool produces the <code>.cpp</code> file, so that it knows about the build dependency:</p> <p></p> <p>Finally, put the <code>/cppfront/include</code> directory on your <code>INCLUDE</code> path. In Solution Explorer, right-click the app and select Properties, and add it to the VC++ Directories &gt; Include Directories:</p> <p></p>"},{"location":"welcome/integration/#thats-it-error-message-outputs-debuggers-visualizers-and-other-tools-should-just-work","title":"That's it: Error message outputs, debuggers, visualizers, and other tools should just work","text":"<p>That's enough to enable builds, and the IDE just picks up the rest from the <code>.cpp</code> file that cppfront generated:</p> <ul> <li> <p>The cppfront error messages in <code>filename(line, col)</code> format. Most C++ IDEs recognize these, and usually automatically merge any diagnostic output wherever compiler error output normally appears. If your IDE prefers <code>filename:line:col</code>, just use the cppfront <code>-format-colon-errors</code> command line option.</p> </li> <li> <p>The <code>#line</code> directives cppfront emits in the generated <code>.cpp</code> file. Most C++ debuggers recognize these and will know to step through the <code>.cpp2</code> file. Note that <code>#line</code> emission is on by default, but if you choose <code>-c</code> (short for <code>-clean-cpp1</code>) these will be suppressed and then the debugger will step through the generated C++ code instead.</p> </li> <li> <p>Regardless of syntax, every type/function/object/namespace/etc. is still just an ordinary C++ type/function/object/namespace/etc. Most C++ debugger visualizers will just work and show beautiful output for the types your program uses, including to use any in-the-box visualizers for all the <code>std::</code> types (since those are used directly as usual) and any custom visualizers you may have already written for your own types or popular library types.</p> </li> </ul>"}]}